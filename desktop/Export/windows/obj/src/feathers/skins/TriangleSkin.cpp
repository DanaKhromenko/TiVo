// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_feathers_core_IDisplayObject
#include <feathers/core/IDisplayObject.h>
#endif
#ifndef INCLUDED_feathers_core_IMeasureObject
#include <feathers/core/IMeasureObject.h>
#endif
#ifndef INCLUDED_feathers_core_IStateObserver
#include <feathers/core/IStateObserver.h>
#endif
#ifndef INCLUDED_feathers_core_IValidating
#include <feathers/core/IValidating.h>
#endif
#ifndef INCLUDED_feathers_core_InvalidationFlag
#include <feathers/core/InvalidationFlag.h>
#endif
#ifndef INCLUDED_feathers_core_MeasureSprite
#include <feathers/core/MeasureSprite.h>
#endif
#ifndef INCLUDED_feathers_core_ValidatingSprite
#include <feathers/core/ValidatingSprite.h>
#endif
#ifndef INCLUDED_feathers_graphics_FillStyle
#include <feathers/graphics/FillStyle.h>
#endif
#ifndef INCLUDED_feathers_graphics_LineStyle
#include <feathers/graphics/LineStyle.h>
#endif
#ifndef INCLUDED_feathers_layout_RelativePosition
#include <feathers/layout/RelativePosition.h>
#endif
#ifndef INCLUDED_feathers_skins_BaseGraphicsPathSkin
#include <feathers/skins/BaseGraphicsPathSkin.h>
#endif
#ifndef INCLUDED_feathers_skins_IProgrammaticSkin
#include <feathers/skins/IProgrammaticSkin.h>
#endif
#ifndef INCLUDED_feathers_skins_ProgrammaticSkin
#include <feathers/skins/ProgrammaticSkin.h>
#endif
#ifndef INCLUDED_feathers_skins_TriangleSkin
#include <feathers/skins/TriangleSkin.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_errors_ArgumentError
#include <openfl/errors/ArgumentError.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_65f639295a6b4894_23_new,"feathers.skins.TriangleSkin","new",0xba04f8cd,"feathers.skins.TriangleSkin.new","feathers/skins/TriangleSkin.hx",23,0xc40152c1)
HX_LOCAL_STACK_FRAME(_hx_pos_65f639295a6b4894_43_get_pointPosition,"feathers.skins.TriangleSkin","get_pointPosition",0x6f7b199d,"feathers.skins.TriangleSkin.get_pointPosition","feathers/skins/TriangleSkin.hx",43,0xc40152c1)
HX_LOCAL_STACK_FRAME(_hx_pos_65f639295a6b4894_46_set_pointPosition,"feathers.skins.TriangleSkin","set_pointPosition",0x92e8f1a9,"feathers.skins.TriangleSkin.set_pointPosition","feathers/skins/TriangleSkin.hx",46,0xc40152c1)
HX_LOCAL_STACK_FRAME(_hx_pos_65f639295a6b4894_65_get_drawBaseBorder,"feathers.skins.TriangleSkin","get_drawBaseBorder",0xe64ba3fd,"feathers.skins.TriangleSkin.get_drawBaseBorder","feathers/skins/TriangleSkin.hx",65,0xc40152c1)
HX_LOCAL_STACK_FRAME(_hx_pos_65f639295a6b4894_68_set_drawBaseBorder,"feathers.skins.TriangleSkin","set_drawBaseBorder",0xc2fad671,"feathers.skins.TriangleSkin.set_drawBaseBorder","feathers/skins/TriangleSkin.hx",68,0xc40152c1)
HX_LOCAL_STACK_FRAME(_hx_pos_65f639295a6b4894_77_drawPath,"feathers.skins.TriangleSkin","drawPath",0xbebfbc3c,"feathers.skins.TriangleSkin.drawPath","feathers/skins/TriangleSkin.hx",77,0xc40152c1)
namespace feathers{
namespace skins{

void TriangleSkin_obj::__construct( ::feathers::graphics::FillStyle fill, ::feathers::graphics::LineStyle border){
            	HX_STACKFRAME(&_hx_pos_65f639295a6b4894_23_new)
HXLINE(  55)		this->_drawBaseBorder = true;
HXLINE(  33)		this->_pointPosition = ::feathers::layout::RelativePosition_obj::TOP_dyn();
HXLINE(  30)		super::__construct(fill,border);
            	}

Dynamic TriangleSkin_obj::__CreateEmpty() { return new TriangleSkin_obj; }

void *TriangleSkin_obj::_hx_vtable = 0;

Dynamic TriangleSkin_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TriangleSkin_obj > _hx_result = new TriangleSkin_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool TriangleSkin_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1f4df417) {
		if (inClassId<=(int)0x093ab78b) {
			if (inClassId<=(int)0x07456291) {
				if (inClassId<=(int)0x0330636f) {
					return inClassId==(int)0x00000001 || inClassId==(int)0x0330636f;
				} else {
					return inClassId==(int)0x07456291;
				}
			} else {
				return inClassId==(int)0x093ab78b;
			}
		} else {
			return inClassId==(int)0x0c89e854 || inClassId==(int)0x1f4df417;
		}
	} else {
		if (inClassId<=(int)0x58123034) {
			if (inClassId<=(int)0x4af7dd8e) {
				return inClassId==(int)0x33776324 || inClassId==(int)0x4af7dd8e;
			} else {
				return inClassId==(int)0x58123034;
			}
		} else {
			return inClassId==(int)0x6b353933 || inClassId==(int)0x7ec87767;
		}
	}
}

 ::feathers::layout::RelativePosition TriangleSkin_obj::get_pointPosition(){
            	HX_STACKFRAME(&_hx_pos_65f639295a6b4894_43_get_pointPosition)
HXDLIN(  43)		return this->_pointPosition;
            	}


HX_DEFINE_DYNAMIC_FUNC0(TriangleSkin_obj,get_pointPosition,return )

 ::feathers::layout::RelativePosition TriangleSkin_obj::set_pointPosition( ::feathers::layout::RelativePosition value){
            	HX_STACKFRAME(&_hx_pos_65f639295a6b4894_46_set_pointPosition)
HXLINE(  47)		if (::hx::IsPointerEq( this->_pointPosition,value )) {
HXLINE(  48)			return this->_pointPosition;
            		}
HXLINE(  50)		this->_pointPosition = value;
HXLINE(  51)		this->setInvalid(::feathers::core::InvalidationFlag_obj::STYLES_dyn());
HXLINE(  52)		return this->_pointPosition;
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriangleSkin_obj,set_pointPosition,return )

bool TriangleSkin_obj::get_drawBaseBorder(){
            	HX_STACKFRAME(&_hx_pos_65f639295a6b4894_65_get_drawBaseBorder)
HXDLIN(  65)		return this->_drawBaseBorder;
            	}


HX_DEFINE_DYNAMIC_FUNC0(TriangleSkin_obj,get_drawBaseBorder,return )

bool TriangleSkin_obj::set_drawBaseBorder(bool value){
            	HX_STACKFRAME(&_hx_pos_65f639295a6b4894_68_set_drawBaseBorder)
HXLINE(  69)		if ((this->_drawBaseBorder == value)) {
HXLINE(  70)			return this->_drawBaseBorder;
            		}
HXLINE(  72)		this->_drawBaseBorder = value;
HXLINE(  73)		this->setInvalid(::feathers::core::InvalidationFlag_obj::STYLES_dyn());
HXLINE(  74)		return this->_drawBaseBorder;
            	}


HX_DEFINE_DYNAMIC_FUNC1(TriangleSkin_obj,set_drawBaseBorder,return )

void TriangleSkin_obj::drawPath(){
            	HX_GC_STACKFRAME(&_hx_pos_65f639295a6b4894_77_drawPath)
HXLINE(  78)		 ::feathers::graphics::LineStyle currentBorder = this->getCurrentBorder();
HXLINE(  79)		Float thicknessOffset = (this->getLineThickness(currentBorder) / ((Float)2.0));
HXLINE(  81)		Float maxX = ::Math_obj::max(((Float)0.0),(this->actualWidth - thicknessOffset));
HXLINE(  82)		Float maxY = ::Math_obj::max(((Float)0.0),(this->actualHeight - thicknessOffset));
HXLINE(  84)		switch((int)(this->_pointPosition->_hx_getIndex())){
            			case (int)0: {
HXLINE( 118)				 ::openfl::display::Graphics _hx_tmp = this->get_graphics();
HXDLIN( 118)				_hx_tmp->moveTo((this->actualWidth / ((Float)2.0)),thicknessOffset);
HXLINE( 119)				if (this->_drawBaseBorder) {
HXLINE( 120)					this->get_graphics()->lineTo(maxX,maxY);
HXLINE( 121)					this->get_graphics()->lineTo(thicknessOffset,maxY);
            				}
            				else {
HXLINE( 123)					this->get_graphics()->lineTo(maxX,this->actualHeight);
HXLINE( 124)					this->get_graphics()->lineStyle(((Float)0.0),null(),((Float)0.0),null(),null(),null(),null(),((Float)0.0));
HXLINE( 125)					this->get_graphics()->lineTo(thicknessOffset,this->actualHeight);
HXLINE( 126)					this->applyLineStyle(currentBorder);
            				}
HXLINE( 128)				 ::openfl::display::Graphics _hx_tmp1 = this->get_graphics();
HXDLIN( 128)				_hx_tmp1->lineTo((this->actualWidth / ((Float)2.0)),thicknessOffset);
            			}
            			break;
            			case (int)1: {
HXLINE( 102)				if (this->_drawBaseBorder) {
HXLINE( 103)					this->get_graphics()->moveTo(thicknessOffset,thicknessOffset);
            				}
            				else {
HXLINE( 105)					this->get_graphics()->moveTo(((Float)0.0),thicknessOffset);
            				}
HXLINE( 107)				 ::openfl::display::Graphics _hx_tmp2 = this->get_graphics();
HXDLIN( 107)				_hx_tmp2->lineTo(maxX,(this->actualHeight / ((Float)2.0)));
HXLINE( 108)				if (this->_drawBaseBorder) {
HXLINE( 109)					this->get_graphics()->lineTo(thicknessOffset,maxY);
HXLINE( 110)					this->get_graphics()->lineTo(thicknessOffset,thicknessOffset);
            				}
            				else {
HXLINE( 112)					this->get_graphics()->lineTo(((Float)0.0),maxY);
HXLINE( 113)					this->get_graphics()->lineStyle(((Float)0.0),null(),((Float)0.0),null(),null(),null(),null(),((Float)0.0));
HXLINE( 114)					this->get_graphics()->lineTo(((Float)0.0),thicknessOffset);
HXLINE( 115)					this->applyLineStyle(currentBorder);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 130)				if (this->_drawBaseBorder) {
HXLINE( 131)					this->get_graphics()->moveTo(thicknessOffset,thicknessOffset);
HXLINE( 132)					this->get_graphics()->lineTo(maxX,thicknessOffset);
            				}
            				else {
HXLINE( 134)					this->get_graphics()->lineStyle(((Float)0.0),null(),((Float)0.0),null(),null(),null(),null(),((Float)0.0));
HXLINE( 135)					this->get_graphics()->moveTo(thicknessOffset,((Float)0.0));
HXLINE( 136)					this->get_graphics()->lineTo(maxX,((Float)0.0));
HXLINE( 137)					this->applyLineStyle(currentBorder);
            				}
HXLINE( 139)				 ::openfl::display::Graphics _hx_tmp3 = this->get_graphics();
HXDLIN( 139)				_hx_tmp3->lineTo((this->actualWidth / ((Float)2.0)),maxY);
HXLINE( 140)				if (this->_drawBaseBorder) {
HXLINE( 141)					this->get_graphics()->lineTo(thicknessOffset,thicknessOffset);
            				}
            				else {
HXLINE( 143)					this->get_graphics()->lineTo(thicknessOffset,((Float)0.0));
            				}
            			}
            			break;
            			case (int)3: {
HXLINE(  86)				if (this->_drawBaseBorder) {
HXLINE(  87)					this->get_graphics()->moveTo(maxX,thicknessOffset);
HXLINE(  88)					this->get_graphics()->lineTo(maxX,maxY);
            				}
            				else {
HXLINE(  90)					this->get_graphics()->moveTo(this->actualWidth,thicknessOffset);
HXLINE(  91)					this->get_graphics()->lineStyle(((Float)0.0),null(),((Float)0.0),null(),null(),null(),null(),((Float)0.0));
HXLINE(  92)					this->get_graphics()->lineTo(this->actualWidth,maxY);
HXLINE(  93)					this->applyLineStyle(currentBorder);
            				}
HXLINE(  95)				 ::openfl::display::Graphics _hx_tmp4 = this->get_graphics();
HXDLIN(  95)				_hx_tmp4->lineTo(thicknessOffset,(this->actualHeight / ((Float)2.0)));
HXLINE(  96)				if (this->_drawBaseBorder) {
HXLINE(  97)					this->get_graphics()->lineTo(maxX,thicknessOffset);
            				}
            				else {
HXLINE(  99)					this->get_graphics()->lineTo(this->actualWidth,thicknessOffset);
            				}
            			}
            			break;
            			default:{
HXLINE( 146)				HX_STACK_DO_THROW( ::openfl::errors::ArgumentError_obj::__alloc( HX_CTX ,(HX_("Triangle pointPosition not supported: ",88,81,1e,f3) + ::Std_obj::string(this->_pointPosition))));
            			}
            		}
            	}



::hx::ObjectPtr< TriangleSkin_obj > TriangleSkin_obj::__new( ::feathers::graphics::FillStyle fill, ::feathers::graphics::LineStyle border) {
	::hx::ObjectPtr< TriangleSkin_obj > __this = new TriangleSkin_obj();
	__this->__construct(fill,border);
	return __this;
}

::hx::ObjectPtr< TriangleSkin_obj > TriangleSkin_obj::__alloc(::hx::Ctx *_hx_ctx, ::feathers::graphics::FillStyle fill, ::feathers::graphics::LineStyle border) {
	TriangleSkin_obj *__this = (TriangleSkin_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TriangleSkin_obj), true, "feathers.skins.TriangleSkin"));
	*(void **)__this = TriangleSkin_obj::_hx_vtable;
	__this->__construct(fill,border);
	return __this;
}

TriangleSkin_obj::TriangleSkin_obj()
{
}

void TriangleSkin_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TriangleSkin);
	HX_MARK_MEMBER_NAME(_pointPosition,"_pointPosition");
	HX_MARK_MEMBER_NAME(_drawBaseBorder,"_drawBaseBorder");
	 ::feathers::skins::BaseGraphicsPathSkin_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TriangleSkin_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_pointPosition,"_pointPosition");
	HX_VISIT_MEMBER_NAME(_drawBaseBorder,"_drawBaseBorder");
	 ::feathers::skins::BaseGraphicsPathSkin_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val TriangleSkin_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"drawPath") ) { return ::hx::Val( drawPath_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"pointPosition") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_pointPosition() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_pointPosition") ) { return ::hx::Val( _pointPosition ); }
		if (HX_FIELD_EQ(inName,"drawBaseBorder") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_drawBaseBorder() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_drawBaseBorder") ) { return ::hx::Val( _drawBaseBorder ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"get_pointPosition") ) { return ::hx::Val( get_pointPosition_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_pointPosition") ) { return ::hx::Val( set_pointPosition_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"get_drawBaseBorder") ) { return ::hx::Val( get_drawBaseBorder_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_drawBaseBorder") ) { return ::hx::Val( set_drawBaseBorder_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val TriangleSkin_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"pointPosition") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_pointPosition(inValue.Cast<  ::feathers::layout::RelativePosition >()) ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_pointPosition") ) { _pointPosition=inValue.Cast<  ::feathers::layout::RelativePosition >(); return inValue; }
		if (HX_FIELD_EQ(inName,"drawBaseBorder") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_drawBaseBorder(inValue.Cast< bool >()) ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_drawBaseBorder") ) { _drawBaseBorder=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TriangleSkin_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_pointPosition",5a,d1,d2,f9));
	outFields->push(HX_("pointPosition",19,e1,80,bb));
	outFields->push(HX_("_drawBaseBorder",a0,b1,b4,68));
	outFields->push(HX_("drawBaseBorder",01,69,54,1f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TriangleSkin_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::feathers::layout::RelativePosition */ ,(int)offsetof(TriangleSkin_obj,_pointPosition),HX_("_pointPosition",5a,d1,d2,f9)},
	{::hx::fsBool,(int)offsetof(TriangleSkin_obj,_drawBaseBorder),HX_("_drawBaseBorder",a0,b1,b4,68)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *TriangleSkin_obj_sStaticStorageInfo = 0;
#endif

static ::String TriangleSkin_obj_sMemberFields[] = {
	HX_("_pointPosition",5a,d1,d2,f9),
	HX_("get_pointPosition",70,ec,f0,c1),
	HX_("set_pointPosition",7c,c4,5e,e5),
	HX_("_drawBaseBorder",a0,b1,b4,68),
	HX_("get_drawBaseBorder",ca,49,ee,ba),
	HX_("set_drawBaseBorder",3e,7c,9d,97),
	HX_("drawPath",c9,8f,bb,5e),
	::String(null()) };

::hx::Class TriangleSkin_obj::__mClass;

void TriangleSkin_obj::__register()
{
	TriangleSkin_obj _hx_dummy;
	TriangleSkin_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("feathers.skins.TriangleSkin",5b,8e,f3,d9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TriangleSkin_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TriangleSkin_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TriangleSkin_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TriangleSkin_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace feathers
} // end namespace skins
